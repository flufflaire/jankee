
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c" //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
// Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
bStopTasksBetweenModes = true;

// All activities that occur before the competition starts
// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
// .....................................................................................
// Insert user code here.
// .....................................................................................
	int flywheel = 0;
	while (flywheel < 100) {
		flywheel++;
		motor[port6] = flywheel;
		motor[port7] = flywheel * -1;
		wait1Msec(50);
	}
	wait1Msec(2500);
	motor[port4] = 100;
	wait1Msec(500);
	while (flywheel > 0) {
		flywheel -= 2;
		motor[port6] = flywheel;
		motor[port7] = flywheel * -1;
	}
	motor[port2] = 50; //wheels move forwards
	motor[port3] = -60;
	wait1Msec(2500);
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
// User control code here, inside the loop
	int WH_switch1 = -1;
	int WH_switch2 = 0;
	int WH1 = 0;
	int WH2 = 0;
	int FW_switch1 = 0;
	int FW_switch2 = 0;
	int FW_bob = 0;
	int flywheel = 0;
	int IN_switch1 = 0;
	int IN_switch2 = 0;
	int FE_switch1 = 0;
	int FE_switch2 = 0;

	while (true)
		{
	// This is the main execution loop for the user control program. Each time through the loop
	// your program should update motor + servo values based on feedback from the joysticks.

	// .....................................................................................
	// Insert user code here. This is where you use the joystick values to update your motors, etc.
	// .....................................................................................

		if (vexRT[Btn7D] == 1 && WH_switch2 == 0) { // WHEEL VARIABLES
			WH_switch1+=2;
			WH_switch2 = 1;
		}
		if (WH_switch1 > 1) WH_switch1 = -1;
		if (vexRT[Btn7D] == 0) WH_switch2 = 0;

		if (WH_switch1 > 0) {
			WH1 = vexRT[Ch2];
			WH2 = vexRT[Ch3];
		} else {
			WH2 = vexRT[Ch2];
			WH1 = vexRT[Ch3];
		}

    if (WH2 > 30 || WH2 < -30) motor[port3] = (int) WH2 * 0.8 * WH_switch1; // RIGHT WHEEL
		else motor[port3] = 0;

		if (WH1 > 30 || WH1 < -30) motor[port2] = (int) WH1 * -0.8 * WH_switch1; // LEFT WHEEL
		else motor[port2] = 0;

		if ((vexRT[Btn6U] == 1 && vexRT[Btn6D] == 1) && FW_switch2 == 0) { //FLYWHEEL VARIABLES
			FW_switch1++;
			FW_switch2 = 1;
		}
		if (FW_switch1 == 2) FW_switch1 = 0;
		if (vexRT[Btn6U] == 0 && vexRT[Btn6D] == 0) FW_switch2 = 0;

		FW_bob++;
		if (FW_bob == 3) FW_bob = 0;

		if (FW_bob == 0 && FW_switch1 == 1 && flywheel <= 100) flywheel+=2;
		else if (FW_switch1 == 0 && flywheel >= 40) flywheel-=2;

		if (vexRT[Btn8U] == 1 && vexRT[Btn8R] == 1) flywheel = 0;

		motor[port6] = flywheel; //flywheel
		motor[port7] = flywheel * -1;

		if (vexRT[Btn5D] == 1 && IN_switch2 == 0) { //INTAKE VARIABLES
			IN_switch1++;
			IN_switch2 = 1;
		} else if (vexRT[Btn8D] == 1 && IN_switch2 == 0) {
			IN_switch1--;
			IN_switch2 = 1;
		}
		if (IN_switch1 == 2 || IN_switch1 == -2) IN_switch1 = 0;
		if (vexRT[Btn5D] == 0 && vexRT[Btn8D] == 0) IN_switch2 = 0;


		if (IN_switch1 == 1) motor[port5] = -80; //intake
		else if (IN_switch1 == -1) motor[port5] = 90;
		else motor[port5] = 0;

		if (vexRT[Btn8L] == 1) motor[port4] = -50;

		if (vexRT[Btn5U] == 1 && FE_switch2 == 0) { //FEEDER VARIABLES
			FE_switch1++;
			FE_switch2 = 1;
		}
		if (FE_switch1 == 2) FE_switch1 = 0;
		if (vexRT[Btn5U] == 0) FE_switch2 = 0;

		if (FE_switch1 == 1) motor[port4] = 100; //FEEDER
		else motor[port4] = 0;

		//A_switch: 0 = off / 1 = retract

		if (vexRT[Btn7U] == 1) { //ARM
			motor[port8] = 100;
		} else if(vexRT[Btn7L] == 1) {
			motor[port8] = -100;
		} else if(vexRT[Btn7R] == 1) {
			motor[port8] = -15;
		} else motor[port8] = 0;
	}
}
